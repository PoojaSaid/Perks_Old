package com.example.demo.Extensions

import org.json.JSONArray
import org.json.JSONObject
import org.springframework.web.bind.annotation.RequestParam
import java.math.BigDecimal
import java.sql.*
import java.util.*
import kotlin.collections.ArrayList


class DBFunctions()
{

    companion object {
        var TablePackage = "com.example.demo.Table";

        val SUCCESS = "SUCCESS";
        val FAILURE = "FAILURE";
        val RESPONSE = "RESPONSE";
        val EXCEPTION = "EXCEPTION"
        val MESSAGE = "MESSAGE"
        const val DATA = "DATA"
        const val STATUS = "STATUS"
        const val SUCCESSFUL = "SUCCESS"
        const val FAILED = "FAILED"
        const val FIELD = "FIELD"




    }


}




fun getSqlStatements(jsonObject: String,conn: Connection) : ArrayList<SQLModel>
{
    var tables = getTablesFromJSON(jsonObject)
    var sqlStatements = ArrayList<SQLModel>()
    for (i in 0 until tables.length()) {
        var tableName = tables.get(i) as String
        var tableRows = getTableRows(jsonObject,tableName)
        var insert = jsonInsert(tableRows, tables.get(i) as String,conn!!)
        var delete = jsonDelete(tableRows, tables.get(i) as String,conn!!)


        //for Delete

        for (x in 0 until delete.size) {

            sqlStatements.add(delete[x])
        }

        //for Insert
        for (x in 0 until insert.size) {
            sqlStatements.add(insert[x])
        }
    }

    return sqlStatements;
}


fun getUpdateStatements(jsonObject: String) : ArrayList<SQLModel>
{
    var tables = getTablesFromJSON(jsonObject)
    var sqlStatements = ArrayList<SQLModel>()
    for (i in 0 until tables.length()) {
        var tableName = tables.get(i) as String
        var tableRows = getTableRows(jsonObject,tableName)
        var update = jsonUpdate(tableRows, tables.get(i) as String)

        //for Insert
        for (x in 0 until update.size) {
            sqlStatements.add(update[x])
        }
    }
    return sqlStatements;
}

fun getTablesFromJSON(prodDetails: String) : JSONArray
{
    return ((JSONObject(prodDetails).get("Tables") as JSONArray).getJSONObject(0)).names()
}

fun getTableRows(prodDetails: String,tableName: String) : JSONArray
{
    return ((JSONObject(prodDetails).get("Tables") as JSONArray).getJSONObject(0)).get(tableName) as JSONArray
}


//Prepares SQL INSERT statement based on the JSONArray passed
//Arguments to be passed are JSONArray and the TableName
fun jsonInsert(jsonArray: JSONArray,tableName: String,conn: Connection) : ArrayList<SQLModel>
{
    var sqlList = ArrayList<SQLModel>()
    var pkKeys = ArrayList<Any>()
    var alColType = buildDataType(tableName,conn)

    for (i in 0 until jsonArray.length())
    {
        var lsSql = "INSERT INTO $tableName (";
        var jsonObject = jsonArray.get(i) as JSONObject
        var autoColumnName = "";

        //Check from the class that the Primary key must me generated from Class or is it autoGenerated ?
        var generatePK = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","shouldGeneratePK")

        //if PK needs to be generated by Spring System (not by Database)
        //then below logic gets executed
        if (generatePK[0].toString().equals("true")) {
            pkKeys = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","getPKKeys")

            //Check Whether primary key exists
            var lbGeneratePK = false;
            for (x in 0 until pkKeys.size) {
                if (jsonObject.has(pkKeys[x].toString()) &&
                        ((jsonObject.isNull(pkKeys[x].toString())) || jsonObject.get(pkKeys[x].toString()) == "null"))
                {
                    lbGeneratePK = true
                    break
                }
                else if (!(jsonObject.has(pkKeys[x].toString()))) //if the key is not present in the jsonObject
                {
                    lbGeneratePK = true
                    break
                }
            }

            //Values are not present
            //so generate the primary key from the class
            //please see there is additional argument to getFunctionFromFile
            //because we need to pass JSONObject and the generatePK method
            //will generate PK and set it in the json object which is returned
            //and then used in Insert Statement
            if (lbGeneratePK)
            {
                var response = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","generatePK",jsonObject)
                jsonObject = response[0] as JSONObject
            }
            var response = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","getAutoGeneratedColumnName")
            autoColumnName = response[0].toString()
        } //if pk needs to be generated by Spring System (not by Database)
        else
        {
            var response = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","getAutoGeneratedColumnName")
            autoColumnName = response[0].toString()
        }

        for (x in 0 until  jsonObject.names().length()) {
            lsSql = lsSql + jsonObject.names().get(x)
            if (x != jsonObject.names().length() - 1)
            {
                lsSql = lsSql+" , ";
            }
            else
            {
                lsSql = lsSql + " ) VALUES (";
            }

        }

        for (x in 0 until  jsonObject.length()) {

            var dataValue : String??
            dataValue =  "'"+jsonObject.get(jsonObject.names().get(x) as String)+"'"
            var colType = filterList(alColType,jsonObject.names().get(x) as String,tableName) as Int

            // if the column types are in numeric category
            // and the value is "''" then put 0 as value
            // Please Note, in case it is mandatory then
            // special care is needed which is still not implemented.

            //not able to use the ENUM Comparision hence hardcoded
            // 2 - Numeric, 3- Decimal, 4- Integer,8-Double
            if (colType == 2 || colType == 3 || colType == 4 || colType == 8)
            {
                if (dataValue.equals("''")) dataValue = "0"
            }
            if (dataValue != null && dataValue.equals("'null'"))
            {
                dataValue = null;
            }
            lsSql = lsSql + dataValue
            if (x != jsonObject.names().length() - 1)
            {
                lsSql = lsSql+" , ";
            }
            else
            {
                lsSql = lsSql + " )";
            }


        }

        jsonObject.put("TABLE",tableName);
        var sqlModel = SQLModel(lsSql,jsonObject,pkKeys,tableName,autoColumnName)
        sqlList.add(sqlModel);
        println("SQL IS "+lsSql)


    }
    return sqlList;
}

fun jsonDelete(jsonArray: JSONArray,tableName: String,conn: Connection) : ArrayList<SQLModel> {
    var sqlList = ArrayList<SQLModel>()
    for (i in 0 until jsonArray.length()) {
        var lsSql = "DELETE FROM $tableName WHERE "
        var deleteKeys = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","getDeleteKeys")
        var jsonObject = jsonArray.get(i) as JSONObject
        var lsWhereClause = ""
        for (x in 0 until deleteKeys.size)
        {
            val lsColumn = deleteKeys[x]
            if (jsonObject.has(deleteKeys[x].toString()) && !(jsonObject.isNull(deleteKeys[x].toString()))) {
                var lsValue = "'" + jsonObject.get(deleteKeys[x].toString()) + "'"
                if (lsWhereClause.length > 0) {
                    lsWhereClause = lsWhereClause + " AND "
                }
                lsWhereClause = lsWhereClause + " " + lsColumn + " = "  + lsValue;
            }
            else
            {
                break
            }

        }
        if (lsWhereClause.length > 0) {
            lsSql = lsSql + lsWhereClause;

            var model = SQLModel(lsSql,jsonObject,ArrayList<Any>(),tableName,"")
            sqlList.add(model)
        }

    }

    return sqlList
}

//prepare Update Statement
fun jsonUpdate(jsonArray: JSONArray,tableName: String) : ArrayList<SQLModel>
{
    var sqlList = ArrayList<SQLModel>()
    for (i in 0 until jsonArray.length())
    {
        var lsSql = "UPDATE $tableName SET ";
        var jsonObject = jsonArray.get(i) as JSONObject

        //get Primary keys


        for (x in 0 until  jsonObject.names().length()) {
            lsSql = lsSql + jsonObject.names().get(x) + " = "+"'"+jsonObject.get(jsonObject.names().get(x) as String)+"'";
            if (x != jsonObject.length() - 1)
            {
                lsSql = lsSql + " , "
            }

        }

        //generate where clause for update
        var pkKeys = getFunctionFromFile(DBFunctions.TablePackage + "."+"$tableName","getPKKeys")
        lsSql = lsSql + " WHERE "
        var validSQL = false;
        for (x in 0 until pkKeys.size)
        {
            if (jsonObject.has(pkKeys[x] as String)) {
                validSQL = true
                if (x == 0) {
                    lsSql = lsSql + pkKeys[x] + " = '" + jsonObject.get(pkKeys[x] as String) + "'"
                } else {
                    lsSql = lsSql + " AND " + pkKeys[x] + " = '" + jsonObject.get(pkKeys[x] as String) + "'"
                }
            }
            else
            {
                break  //Primary key is not set hence break the SQL Update Statement
            }
        }

        if (validSQL) {
            var model = SQLModel(lsSql,jsonObject,pkKeys,tableName,"")
            sqlList.add(model)
        }
        println("SQL IS "+lsSql)


    }
    return sqlList;
}

fun rowsToJson(rows : List<Map<String,Any>>)
{
    for (i in 0 until rows.size)
    {
        var jsonObject = JSONObject()
        for (x in 0 until rows.get(0).keys.size) {
            //jsonObject.put(rows.get(i).keys,rows.get(x).getValue("abc"))
        }
    }


}

fun getFunctionFromFile(fileName: String, funcName: String):ArrayList<Any> {
    val cls = Class.forName(fileName)
    val kotlinClass = cls.kotlin
    val keys = (cls.getMethod(funcName).invoke(kotlinClass.java.newInstance()) as ArrayList<Any>)
    return keys
}


fun getFunctionFromFile(fileName: String, funcName: String,jsonObject: JSONObject):ArrayList<Any> {
    val cls = Class.forName(fileName)
    val kotlinClass = cls.kotlin
    val klass = kotlinClass.java.newInstance()
    val method = klass.javaClass.getMethod(funcName,JSONObject().javaClass)
    //val keys = klass.invoke(jsonObject) as ArrayList<Any>
    val keys = method.invoke(klass,jsonObject) as ArrayList<Any>
    return keys
}


fun buildDataType(tableName: String,conn: Connection): ArrayList<DBModel>
{
    var list = ArrayList<DBModel>()
    var st = conn.createStatement()
    var rs = st.executeQuery("SELECT * FROM $tableName WHERE 1 = 2")
    var metaData = rs.metaData
    for (i in 1.. metaData.columnCount) {
        var colName = metaData.getColumnName(i)
        var colType = metaData.getColumnType(i)
        var model = DBModel(colName,colType);
        list.add(model)
    }
    return list
}




fun rowsToJsonArray(lsSql: String,conn: Connection?) : JSONArray
{
    var stmt = conn!!.createStatement()
    var rs =   stmt.executeQuery(lsSql)
    var metaData = rs.metaData
    var jsonArray = JSONArray()
    while (rs!!.next()) {
        var jsonObject = JSONObject()
        for (i in 1.. metaData.columnCount) {
            var colType = metaData.getColumnType(i)
            if (colType.equals(JDBCType.INTEGER))
            {
                jsonObject.put(metaData.getColumnLabel(i),rs.getNullableInt(metaData.getColumnLabel(i)))
            }
            else if (colType.equals(JDBCType.DOUBLE))
            {
                jsonObject.put(metaData.getColumnLabel(i),rs.getNullableDouble(metaData.getColumnLabel(i)))
            }
            else
            {
                if (rs.getNullableString(metaData.getColumnLabel(i)) == null) {
                    jsonObject.put(metaData.getColumnLabel(i), JSONObject.NULL)
                }
                else
                {
                    jsonObject.put(metaData.getColumnLabel(i), rs.getNullableString(metaData.getColumnLabel(i)))
                }
            }

        }
        jsonArray.put(jsonObject)
    }

    return jsonArray
}

fun getDBConnection() :Connection?
{
    val connectProps = Properties()


    connectProps.put("user","root")
    connectProps.put("password","root")

    /*
    connectProps.put("user","root")
    connectProps.put("password","MySql1234")
    */

    var conn: Connection? = null;

    try {
        Class.forName("com.mysql.jdbc.Driver").newInstance()
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/perkskn3_old?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false",connectProps)
        //conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/SocAdmin?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&useSSL=false",connectProps)

    }
    catch(ex: SQLException)
    {
        ex.printStackTrace();
    }
    catch(ex: Exception)
    {
        ex.printStackTrace()
    }
    return conn
}


fun ResultSet.getNullableLong(colName: String) : Long?
{
    val value = this.getLong(colName)
    return if (this.wasNull()) null else value
}

fun ResultSet.getNullableString(colName: String) : String?
{
    val value = this.getString(colName)
    return if (this.wasNull()) null else value
}

fun ResultSet.getNullableDouble(colName: String) : Double?
{
    val value = this.getDouble(colName)
    return if (this.wasNull()) null else value
}

fun ResultSet.getNullableBigDecimal(colName: String) : BigDecimal?
{
    val value = this.getBigDecimal(colName)
    return if (this.wasNull()) null else value
}

fun ResultSet.getNullableInt(colName: String) : Int?
{
    val value = this.getInt(colName)
    return if (this.wasNull()) null else value
}


class SQLModel
{
    public var statement = ""
    public var jsonObject = JSONObject()
    public var responseKEY = ArrayList<Any>()
    public var tableName = ""
    public var autoGeneratedColumn = ""


    constructor(sqlStatement: String,json: JSONObject,pkKeys: ArrayList<Any> ,tableName: String,autoColumn: String)
    {
        statement = sqlStatement
        jsonObject = json
        responseKEY = pkKeys
        this.tableName = tableName
        autoGeneratedColumn = autoColumn
    }

}


class DBModel
{
    var colName = "";
    var colType = 0;
    constructor(colName: String,colType: Int)
    {
        this.colName = colName
        this.colType = colType
    }
}

fun filterList(listCustom: List<DBModel>?,colName: String,tableName: String) : Int {

    if (listCustom!!.filter { it.colName == colName }.size > 0)
    {
        var filterList = listCustom!!.filter { it.colName == colName}
        return filterList[0].colType
    }
    else
    {
        throw Exception("Column $colName not Found in $tableName");
    }

}


fun getResponseData(lsCode :String,lsMessage :String) :JSONObject
{
    var jsonResponse = JSONObject()
    jsonResponse.put("RESPONSE",lsCode);
    jsonResponse.put("MESSAGE",lsMessage)
    return jsonResponse;
}


fun execUpdate(
        @RequestParam("conn") conn: Connection?,
        @RequestParam("sql") lsSql: String)
{


    var stmt = conn!!.prepareStatement(lsSql)
    stmt.executeUpdate(lsSql)}





