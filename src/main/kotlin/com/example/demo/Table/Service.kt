package com.example.demo.Table

import com.example.demo.Extensions.SQLModel
import com.example.demo.Extensions.getDBConnection
import com.example.demo.Extensions.getResponseData
import com.example.demo.Extensions.jsonInsert
import com.example.demo.RESPONSE_TECH_ERROR
import org.json.JSONArray
import org.json.JSONObject
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.multipart.MultipartFile
import java.sql.PreparedStatement
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import kotlin.collections.ArrayList

class Service {
    companion object
    {
        val TABLE_NAME="Service"
        const val SRVID="srv_Id"
        const val SRVNAME="srv_Name"
        const val SRVDESCRIPTION="srv_description"
        const val SRVCATID="srv_catId"
        const val SRVCOST="srv_cost"
        const val SRVCOSTUNIT="srv_costUnit"
        const val SRVIMAGE="srv_Image"
        const val SRVCREATEDBY="srv_createdBy"
        const val SRVCREATEDDATETIM="srv_createdDateTime"
        const val SRVUPDATEDBY="srv_updatedBy"
        const val SRVUPDATEDDATETIM="sr_uUpdatedDateTime"
        const val SRVISACTIVE="srv_isActive"

        var deleteKeys = arrayListOf(SRVID)
        var generatePrimaryKey = true

        var autoGeneratedColumn = arrayListOf(SRVID)

        var primaryKeys = arrayListOf(SRVID)

    }

    fun getDeleteKeys(): ArrayList<String> {
        return deleteKeys
    }

    fun getPKKeys(): ArrayList<String> {
        return primaryKeys
    }


    fun shouldGeneratePK(): ArrayList<Boolean> {
        val al = ArrayList<Boolean>()
        al.add(generatePrimaryKey)
        return al
    }


    fun getAutoGeneratedColumnName(): ArrayList<String> {
        return autoGeneratedColumn
    }

}


class ServiceWS {
    fun postService(
            @RequestParam("name", required = true) name: String,
            @RequestParam("description", required = true) description: String,
            @RequestParam("image", required = true) image:MultipartFile?

    ): String {

        var active = 'Y'
        var lsMsg = ""
        var conn = getDBConnection()
        conn!!.autoCommit = false

        lateinit var preparedStatement: PreparedStatement
        var sqlStatement = ArrayList<SQLModel>()

        //Image File
        var fileName=""
        if (image!=null)
        {
            if (image.isEmpty.not())
            {
                var filePath=Validation().getPath()
                val uuid=UUID.randomUUID()
                fileName="Data:"+uuid+".png"
            }
            else
            {
                return fileName
            }
        }

        //validation
        var msg = "Validation Error"
        val namevalidation = Validation().maxRangeValidation(name)
        val descriptionvalidation = Validation().maxRangeValidation(description)

        var validationDone: Boolean = true
        if (!namevalidation) {

            Validation().genMsg("Name should not be greater than 255 character")
            validationDone = false
        }
        if (!descriptionvalidation) {

            Validation().genMsg("Name should not be greater than 255 char")
            validationDone = false
        }
        if (!validationDone && lsMsg.length > 0) {

            var ErroRes = Validation().validationMsg(lsMsg)
            return ErroRes.toString()
        }

        //For Auto-generating Cust-ID
        val atomicInteger = AtomicInteger()
        var id = atomicInteger.getAndIncrement()


        var checkObject = JSONObject().apply {
            put(Service.SRVID, id)
            put(Service.SRVNAME, name)
            put(Service.SRVISACTIVE, active)
            put(Service.SRVDESCRIPTION, description)
            put(Service.SRVIMAGE,fileName)
        }

        try {
                var jsonArray = JSONArray()
                jsonArray.put(checkObject)
                var insert = jsonInsert(jsonArray, Service.TABLE_NAME, conn!!)

                for (i in 0 until insert.size) {
                    sqlStatement.add(insert[i])
                }

                try {
                    for (i in 0 until sqlStatement.size) {
                        var e = sqlStatement[i]
                        var preparedStatement = conn!!.prepareStatement(e.statement)
                        preparedStatement.executeUpdate()
                    }
                    conn!!.commit()
                } catch (e: Exception) {
                    conn!!.rollback()
                    conn!!.close()

                    var jsonResponse = getResponseData(RESPONSE_TECH_ERROR, e.toString())
                }
            } catch (e: java.lang.Exception) {
                conn?.rollback()
                return Validation().getStatusMessage("Failed", "Error while inserting data".plus("${e.message}"))
            } finally {
                conn?.close()
            }
            return Validation().getStatusMessage("Success", "Record inserted successully")
        }
    }

