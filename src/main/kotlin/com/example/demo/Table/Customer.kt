package com.example.demo.Table


import com.example.demo.Extensions.*
import com.example.demo.RESPONSE_TECH_ERROR
import org.json.JSONArray
import org.json.JSONObject
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.multipart.MultipartFile
import java.io.File
import java.sql.PreparedStatement
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import kotlin.collections.ArrayList


class Customer {

    companion object {
        val TABLE_NAME = "Customer"
        const val CUST_ID = "custId"
        const val CUST_NAME = "cust_name"
        const val CUST_FIRSTNAME = "cust_firstname"
        const val CUST_MIDDLENAME = "cust_middlename"
        const val CUST_LASTNAME = "cust_lastname"
        const val CUST_DOB = "cust_dob"
        const val CUST_EMAIL = "cust_email"
        const val CUST_MOBILENO = "cust_mobileNo"
        const val CUST_ALTERNATEMOBNO = "cust_alternateMobNo"
        const val CUST_HOUSINGSOC = "cust_housingSoc"
        const val CUST_REGISTRATIONDATE = "cust_registrationDate"
        const val CUST_PASSWORD = "cust_password"
        const val CUST_IMAGE = "cust_image"
        const val CUST_CREATEDBY = "cust_createdBy"
        const val CUST_CREATEDDATETIME = "cust_createdDateTime"
        const val CUST_UPDATEDBY = "cust_updatedBy"
        const val CUST_UPDATEDATETIME = "cust_updatedDateTime"
        const val CUST_ISACTIVE = "cust_isActive"
        const val API_TOKEN = "api_token"
        const val API_TOKEN_EXP_DATE = "api_token_exp_date"
        const val SECRET_ID = "secret_id"
        const val SECRET_ANSWER = "secret_answer"
        const val DEVICE_ID = "device_id"

        var deleteKeys = arrayListOf(CUST_ID)
        var generatePrimaryKey = true

        var autoGeneratedColumn = arrayListOf(CUST_ID)

        var primaryKeys = arrayListOf(CUST_ID)

    }

    fun getDeleteKeys(): ArrayList<String> {
        return deleteKeys
    }

    fun getPKKeys(): ArrayList<String> {
        return primaryKeys
    }


    fun shouldGeneratePK(): ArrayList<Boolean> {
        val al = ArrayList<Boolean>()
        al.add(generatePrimaryKey)
        return al
    }


    fun getAutoGeneratedColumnName(): ArrayList<String> {
        return autoGeneratedColumn
    }

}


class CustomerDetailsWS() {

    var lsMsg = ""

    /*****CUSTOMER REGISTRATION****/
    fun custRegistration(
            name: String,
            email: String,
            mobile: String,
            housing: String,
            password: String,
            imageFile: MultipartFile?
    ): String {


        var conn = getDBConnection()
        conn!!.autoCommit = false

        lateinit var preparedStatement: PreparedStatement
        var sqlStatements = ArrayList<SQLModel>()


        //For image file Stroring
        var fileName = ""
        if (imageFile != null) {
            if (imageFile.isEmpty.not()) {
                var filePath = Validation().getPath()
                val uuid = UUID.randomUUID()
                fileName = "Data:" + uuid + ".png"

            } else {
                return fileName
            }
        }


        //Validation
        var msg = "Validation Error"
        val namevalidation = Validation().maxRangeValidation(name)
        val emailvalidation = Validation().maxRangeValidation(email)
        val mobilevalidation = Validation().mobileNoValidation(mobile)
        val housingvalidation = Validation().maxRangeValidation(housing)
        val passwordvalidation = Validation().passwordValidation(password)

        var validationDone: Boolean = true
        if (!namevalidation) {

            Validation().genMsg("Name should not be greater than 255 char")
            validationDone = false
        }
        if (!emailvalidation) {

            Validation().genMsg("Email should not be greater than 255 char")
            validationDone = false
        }
        if (!mobilevalidation) {

            Validation().genMsg("Mobile should not be greater than 10 char")
            validationDone = false
        }
        if (!housingvalidation) {

            Validation().genMsg("Housing soc should not be greater than 255 char")
            validationDone = false
        }
        if (!passwordvalidation) {

            Validation().genMsg("Password should not be greater than 6 char")
            validationDone = false
        }


        if (!validationDone && lsMsg.length > 0) {

            var ErroRes = Validation().validationMsg(lsMsg)
            return ErroRes.toString()
        }

        //For Auto-generating Cust-ID
        val atomicInteger = AtomicInteger()
        var IsCUST_ID = atomicInteger.getAndIncrement()


        //JSON Object for Adding of all functionality
        var checkObject = JSONObject().apply {
            put(Customer.CUST_ID, IsCUST_ID)
            put(Customer.CUST_NAME, name)
            put(Customer.CUST_EMAIL, email)
            put(Customer.CUST_MOBILENO, mobile)
            put(Customer.CUST_HOUSINGSOC, housing)
            put(Customer.CUST_PASSWORD, password)
            put(Customer.CUST_IMAGE, fileName)
        }

        //Insert Data
        try {
            var jsonArray = JSONArray()
            jsonArray.put(checkObject)
            var insert = jsonInsert(jsonArray, Customer.TABLE_NAME, conn!!)

            for (i in 0 until insert.size) {
                sqlStatements.add(insert[i])
            }

            try {
                for (i in 0 until sqlStatements.size) {

                    var e = sqlStatements[i]
                    var prepareStatement = conn!!.prepareStatement(e.statement)
                    prepareStatement.executeUpdate()
                }
                conn.commit()
            } catch (e: Exception) {
                conn!!.rollback()
                conn!!.close()
                var jsonResponse = getResponseData(RESPONSE_TECH_ERROR, e.toString())

            }
        } catch (e: Exception) {
            conn?.rollback()
            return Validation().getStatusMessage("Failed", "Error while inserting record".plus("${e.message}"))
        } finally {
            conn?.close()
        }
        return Validation().getStatusMessage("Success", "Record successfully Inserted")

    }


    /*****GET CUSTOMER DETAILS*****/
    fun getCustomer( custID: String,
                    custPassword: String,
                    custMobileNo: String
    ): String {

        var conn = getDBConnection()
        var jsonResult = JSONObject()

        var lsBaseTableSql = "FROM ${Customer.TABLE_NAME}"

        var lsSql = "SELECT * $lsBaseTableSql "

        var lsWhere = " "

        if (custID.isNullOrEmpty().not()) {
            lsWhere = " WHERE ${Customer.CUST_ID} = '$custID'"

        }

        if (custPassword.isNullOrEmpty().not()) {
            lsWhere = lsWhere + " AND ${Customer.CUST_PASSWORD}='$custPassword'"
        }

        if (custMobileNo.isNullOrEmpty().not()) {
            lsWhere = lsWhere + " AND ${Customer.CUST_MOBILENO} = '$custMobileNo' OR" +
                    " ${Customer.CUST_EMAIL} = '$custMobileNo'"
        }

        lsSql = lsSql + lsWhere


        var jsonArray = rowsToJsonArray(lsSql, conn)

        var IsPageSql = "SELECT COUNT(*) as dataCount " + lsBaseTableSql + "$lsWhere"

        var stmt = conn!!.createStatement()
        var rs = stmt.executeQuery(IsPageSql)

        var totalRows = 0

        while (rs!!.next()) {
            totalRows = rs.getNullableInt("dataCount")!!
        }
        jsonResult.apply {
            put("TOTAL_ROWS", totalRows)
            put("DATA", jsonArray)
            put("STATUS", DBFunctions.SUCCESS)
            put("SQL", lsSql)
        }


        conn!!.close()

        return jsonResult.toString()

    }


    /*****CHANGE PASSWORD *****/
    fun forgetPasword(mobile: String,
                      password: String
    ): String {
        var conn = getDBConnection()
        conn!!.autoCommit = false

        lateinit var preparedStatement: PreparedStatement


        //validation of mobile and password
        val mobilevalidation = Validation().mobileNoValidation(mobile)
        val passwordvalidation = Validation().passwordValidation(password)
        var validationDone: Boolean = true
        if (!mobilevalidation) {
            Validation().genMsg("Mobile length should be equal to 10 char")
            validationDone = false

        }
        if (!passwordvalidation) {
            Validation().genMsg("Password should be greater than 6 char")
            validationDone = false

        }
        if (!validationDone && lsMsg.length > 0) {

            var ErroRes = Validation().validationMsg(lsMsg)
            return ErroRes.toString()
        }

        var IsBaseSQL = " SET cust_password = '${password}' "

        var IsSQL = "UPDATE ${Customer.TABLE_NAME}"

        var IsWhere = ""

        if (mobile.isNullOrEmpty().not()) {
            IsWhere = IsWhere + " WHERE cust_mobileNo = '${mobile}';"
        }
        IsSQL = IsSQL + IsBaseSQL + IsWhere


        var count:Int=0
        //Updating Data
        try {

            var ps = conn.prepareStatement(IsSQL)

            count= ps.executeUpdate()


        } catch (e: Exception) {
            conn?.rollback()
            return Validation().getStatusMessage("Failed", "Error while Updating password".plus(" ${e.message}")).toString()

        } finally {
            conn?.close()
        }

        return Validation().getStatusMessage("Success", "Updated successfully").toString()
    }

}









